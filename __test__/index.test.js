var express = require("express");
var router = express.Router();
const Course = require("../models/Course");
const Setting = require("../models/Setting");
const { checkDegree, checkCourseId } = require("../middleware/checkCourse");

/* GET home page. */
router.get("/courses/:degree", [checkDegree], async function (req, res, next) {
  const degree = req.degree;
  const courses = await Course.find({ degree: degree, is_show: true }).exec();
  return res.json({ courses: courses });
});

router.get(
  "/courses/:degree/all",
  [checkDegree],
  async function (req, res, next) {
    const degree = req.degree;
    const courses = await Course.find({ degree: degree }).exec();
    return res.json({ courses: courses });
  }
);

router.post(
  "/course/:course_id/change-show-status",
  [checkCourseId],
  async function (req, res, next) {
    const course_id = req.course_id;
    const { is_show } = req.body;
    try {
      await Course.updateOne({ _id: course_id }, { is_show: is_show });
      return res.json({ success: true });
    } catch (error) {
      return res.sendStatus(500);
    }
  }
);

router.delete(
  "/course/:course_id",
  [checkCourseId],
  async function (req, res, next) {
    const course_id = req.course_id;
    try {
      await Course.deleteOne({ _id: course_id });
      return res.json({ success: true });
    } catch (error) {
      return res.sendStatus(500);
    }
  }
);

router.get("/setting/academic-year", async function (req, res, next) {
  const academic_year = await Setting.findOne({
    _id: "academic-year",
  }).exec();
  return res.json({ academic_year });
});

// router.post(
//   "/setting/acdemic-year",
//   async function (req, res, next) {
//     const { semester, year } = req.body;
// 	if(semester) {
// 		try {
// 			await Setting.updateOne({ _id: course_id }, { is_show: is_show });
// 			return res.json({ success: true });
// 		} catch (error) {
// 		return res.sendStatus(500);
// 		}
// 	}
//   }
// );

module.exports = router;

// Generated by CodiumAI

describe('code snippet', () => {

    // GET request to /courses/:degree returns courses with is_show=true
    it('should return courses with is_show=true when making a GET request to /courses/:degree', async () => {
      const req = {
        degree: "ms"
      };
      const res = {
        json: jest.fn()
      };
      const Course = {
        find: jest.fn().mockReturnThis(),
        exec: jest.fn().mockResolvedValueOnce([{ degree: "ms", is_show: true }])
      };

      await router.handle(req, res, async () => {
        const degree = req.degree;
        const courses = await Course.find({ degree: degree, is_show: true }).exec();
        return res.json({ courses: courses });
      });

      expect(Course.find).toHaveBeenCalledWith({ degree: "ms", is_show: true });
      expect(res.json).toHaveBeenCalledWith({ courses: [{ degree: "ms", is_show: true }] });
    });

        // DELETE request to "/course/:course_id" deletes course with matching course_id and returns success message
    it('should delete course with matching course_id and return success message when DELETE request is made to "/course/:course_id"', async () => {
      const req = {
        course_id: '12345'
      };
      const res = {
        json: jest.fn()
      };
      const Course = {
        deleteOne: jest.fn().mockResolvedValueOnce({ success: true })
      };

      const mockRouter = {
        get: jest.fn(),
        post: jest.fn(),
        delete: jest.fn(),
        stack: [
          { route: { stack: [] } },
          { route: { stack: [] } },
          { route: { stack: [] } },
          { route: { stack: [] } },
          { route: { stack: [] } },
          { route: { stack: [] } },
          { route: { stack: [] } },
          { route: { stack: [] } },
          {
            route: {
              stack: [
                {
                  handle: jest.fn().mockImplementation(async (req, res, next) => {
                    const course_id = req.course_id;
                    try {
                      await Course.deleteOne({ _id: course_id });
                      return res.json({ success: true });
                    } catch (error) {
                      return res.sendStatus(500);
                    }
                  })
                }
              ]
            }
          }
        ]
      };

      await mockRouter.stack[8].route.stack[0].handle(req, res);

      expect(Course.deleteOne).toHaveBeenCalledWith({ _id: '12345' });
      expect(res.json).toHaveBeenCalledWith({ success: true });
    });

    // DELETE request to "/course/:course_id" deletes course with matching course_id and returns success message
    it('should delete course with matching course_id and return success message when DELETE request is made to "/course/:course_id"', async () => {
        const req = {
          course_id: '12345'
        };
        const res = {
          json: jest.fn()
        };
        const Course = {
          deleteOne: jest.fn().mockResolvedValueOnce({ success: true })
        };
  
        const mockRouter = {
          get: jest.fn(),
          post: jest.fn(),
          delete: jest.fn(),
          stack: [
            { route: { stack: [] } },
            { route: { stack: [] } },
            { route: { stack: [] } },
            { route: { stack: [] } },
            { route: { stack: [] } },
            { route: { stack: [] } },
            { route: { stack: [] } },
            { route: { stack: [] } },
            {
              route: {
                stack: [
                  {
                    handle: jest.fn().mockImplementation(async (req, res, next) => {
                      const course_id = req.course_id;
                      try {
                        await Course.deleteOne({ _id: course_id });
                        return res.json({ success: true });
                      } catch (error) {
                        return res.sendStatus(500);
                      }
                    })
                  }
                ]
              }
            }
          ]
        };
  
        await mockRouter.stack[8].route.stack[0].handle(req, res);
  
        expect(Course.deleteOne).toHaveBeenCalledWith({ _id: '12345' });
        expect(res.json).toHaveBeenCalledWith({ success: true });
      });

    // GET request to "/courses/:degree/all" returns all courses for the given degree
    it('should return all courses for the given degree when a GET request is made to "/courses/:degree/all"', async () => {
        const express = require('express');
        const supertest = require('supertest');
        const router = require('../routes/code_under_test'); // Fix: Corrected the path to the 'code_under_test' module
        const Course = require('../models/Course');
  
        // Mock the Course model
        jest.mock('../models/Course');
        const mockCourse = {
          find: jest.fn().mockReturnThis(),
          exec: jest.fn(),
        };
        Course.mockReturnValue(mockCourse);
  
        // Create a test app
        const app = express();
        app.use('/', router);
  
        // Mock the request and response objects
        const req = { params: { degree: 'testDegree' } };
        const res = { json: jest.fn() };
  
        // Mock the Course.find().exec() method
        mockCourse.exec.mockResolvedValueOnce([{ course: 'testCourse' }]);
  
        // Make the GET request
        await supertest(app).get('/courses/testDegree/all').send(req).expect(200);
  
        // Check that the Course.find() method was called with the correct parameters
        expect(mockCourse.find).toHaveBeenCalledWith({ degree: 'testDegree' });
  
        // Check that the Course.find().exec() method was called
        expect(mockCourse.exec).toHaveBeenCalled();
  
        // Check that the response was sent with the correct data
        expect(res.json).toHaveBeenCalledWith({ courses: [{ course: 'testCourse' }] });
      }); 
      

});
